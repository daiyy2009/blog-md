# 面向对象的程序设计
## 理解对象
### 属性类型
- 有两种：数据属性和访问器属性。

#### 数据属性：

1. `[[Configurable]]`:表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性。
2. ` [[Enumerable]]`：表示能否通过 `for-in` 循环枚举属性。
3. `[[Writable]]`：表示能否修改属性的值。
4. ` [[Value]]`：表示属性数据值。默认为 `undefined`。

- 需要注意的是，前三个属性，直接在对象上定义属性时，默认都是 `true`，但是如果用 `Object.defineProperty（）`方法，不写明默认为` false`.
- `Object.defineProperty()`接受三个参数，对象名，属性，一个 json 对象（描述符对象）。其中描述符独享的属性必须是` configurable、enumerable、writable、value`。

```javascript
     //Object.defineProperty()默认configurable 等属性均为 false
      var person = {}
      Object.defineProperty(person,'name',{
        value:'Nicholas'
      })
      console.log(person.name)  //Nicholas
      person.name = 'James'
      console.log(person.name)  //Nicholas
```

- 可以多次修改同一个属性通过` Object.defineProperty()`方法，但` Configurable`属性一旦设置为 false，就再也无法改回，而且除了` Writable`属性可以继续修改，其他的都没法改动了。

#### 访问器属性：

1. `[[Configurable]]`同上。
2. `[[Enumerable]]`同上。
3. `[[Get]]`读取属性时调用的函数，默认为`undefined`.
4. `[[Set]]`写入属性时调用的函数，默认为`undefined`.

- 访问器属性不包含数据值，取而代之的是一对儿 getter 和 setter 函数（非必须）。
- `_year`前面的下划线约定俗成的表示只能通过对象方法访问的属性。
- getter和 setter 不需要同时指定，代表只能读不能写或者只写不能读，只指定 getter 函数时，写入属性会被忽略，严格模式下报错。

```javascript
   //Object.defineProperty（)方法为访问器属性添加 getter/setter函数
    var book = {
      _year: 2004,
      edition: 1
    }

    Object.defineProperty(book, 'year', {
      get: function () {
        return this._year
      },
      set: function (value) {
        if (value > 2004) {
          this._year = value
          this.edition += value - 2004
        }
      }
    })
    book.year = 1999
    console.log(book.edition,book.year) //get方法了_year 的值给了 book.year
    book.year = 2005
    console.log(book.edition)
```

#### 定义多个属性
- `Object.defineProperties()`接受两个参数，第一个是要添加和修改属性的对象，第二个是一个 json 对象，包含一一对应的属性和值。
- 和之前的单个方法基本类似的。

## 创建对象
### 工厂模式
- 工厂模式抽象了创建具体对象的过程，用函数封装以特定接口创建对象的细节，在函数内部创建对象赋予属性和方法，最后返回这个对象。
- 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。

### 构造函数模式
- 构造函数模式和工厂模式极其类似，只不过函数名大写开头，没有显示的创建对象，把属性和方法直接付给了 `this` 对象，而且没有` return`语句。
- 按照惯例，构造函数始终以大写字母开头，非构造函数应该以小写字母开头。
- 实际上构造函数的调用经历了下面四个过程：

1. 创建一个新对象
2. 将构造函数的作用域赋给新对象，从而 `this` 就指向了新对象
3. 执行构造函数的代码，为新对象添加新属性
4. 返回新对象

```javascript
function Person(name, age) {
	this.name = name
	this.age = age
	this.sayHi = function() {
		console.log('hi')
	}
}
var person1 = new Person('james', 29)
```

- `person1`实例有一个` constructor`构造函数属性，指向的是构造函数 `Person`。
- 创建自定义的构造函数可以将他的实例标识为一种特定的类型，这正是胜过工厂模式的地方。

#### 构造函数当做函数

```javascript
Person('Nicholas', 29) 
console.log(window.sayHi()) //hi

Person.call(o, 'James', 33) //通过 call 和 apply 等进行特殊作用域调用
```

- 构造函数与其他函数的唯一区别，就在于调用的方式不同。任何函数，只要通过new 操作符进行调用，那么他就可以作为构造函数，不通过 new 来调用，和其他函数无异。
- 直接调用的话，不通过 new 操作符，会被添加到 window 对象。

#### 构造函数的问题
- 每个方法都要在实例上重新定义一遍，即使函数是完全一样的。如果把方法变成全局函数声明，全局作用域有点名不符实，而且太多的全局方法完全没有了封装性可言。

## 原型模式
- 每一个函数都有一个` prototype` 属性，是一个指针，指向一个对象，这个对象包含了有特定类型所有实例共享的属性和方法。



















